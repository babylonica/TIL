# 알고리즘

: 단계를 통해 문제를 해결하기 위한 절차나 방법

- 문제를 해결하기 위해 다양한 알고리즘을 사용할 수 있고, 최적의 알고리즘을 찾는 것이 중요



## 좋은 알고리즘이란?

1. 정확성 : 얼마나 정확하게 동작하는가
2. 작업량 : 얼마나 적은 연산으로 결과를 얻어내는가
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
4. 단순성 : 얼마나 단순한가
5. 최적성 : 더이상 개선의 여지가 없는가



> 시간 복잡도(Time Complexity)

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산



> 빅-오 표기법

- 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만을 표시

  ex)

  O(3n+2) = O(3n) = O(n)



## 배열

: 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조



## 정렬(Sort)

: 2개 이상의 자료를 특정 기준에 의해 재배열하는 것 (오름차순 or 내림차순)

- 정렬 방식의 종류
  - **버블**
  - 카운팅 
  - **선택**
  -  퀵
  -  삽입
  -  병합 정렬 등



> 버블 정렬

: 인접한 두 개의 원소를 비교하며 자리를 교환하는 방식

- 비교와 교환 방식

- 첫번째 원소부터 인접한 원소끼리 자리를 교환하며 맨 마지막 자리까지 이동 ... 한 단계
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨 



> 카운팅 정렬

: 집합에 각 항목이 몇 개씩 있는지 세는 작업 진행

- 비교환 방식
- 정수로 표현 가능한 자료에 대해서만 적용 가능
- 집합 내 가장 큰 정수를 알아야 한다



> 완전 검색

: 모든 경우의 수를 테스트(중복 포함) 해보고 최종 결과를 도출

( = Brute-Force 기법)



> 순열(Permutation)

: 서로 다른 것들 중 뽑아 한줄로 나열

- `nPr` : 서로 다른 n개 중 r개를 선택

- nPr = n * (n-1) * (n-2) * ... * (n-r+1)

  = n!/(r! * (n-r)!)

  - 총 r개의 항
  - nPn = n!



> 탐욕 알고리즘(Greedy)

: 최적해를 구하는데 사용되는 방법

- 순간순간 최적이라고 생각되는 것을 선택해 나가는 방식

1. 해 선택 : 순간의 최적 해를 집합에 추가
2. 실행 가능성 검사 : 실행 가능 / 조건 충족 여부 확인
3. 해 검사 
